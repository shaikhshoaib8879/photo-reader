<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Photo Reader OCR</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/cropperjs@1.6.2/dist/cropper.min.css" />
  <script src="https://unpkg.com/nspell/dist/nspell.js"></script>
  <script src="config.js" defer></script>
  <style>
    /* Ensure modal scroll doesn't shrink cropper unexpectedly */
    #cropperImage { max-width: 100%; }
    /* Active aspect ratio button (manual since we cannot use @apply here) */
    .ar-btn.active { background-color:#4f46e5; color:#fff; }
  </style>
</head>
<body class="min-h-full bg-gray-50 text-gray-800">
  <div class="max-w-3xl mx-auto py-10 px-4">
    <h1 class="text-3xl font-bold mb-6 text-center">Photo Reader OCR</h1>

    <div class="bg-white shadow rounded-lg p-6">
      <form id="ocrForm" class="space-y-4">
        <div>
          <label class="block text-sm font-medium mb-1" for="imageInput">Select an image</label>
          <input id="imageInput" name="image" type="file" accept="image/*" class="block w-full text-sm text-gray-900 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100" required />
        </div>

        <div id="previewWrapper" class="hidden space-y-2">
          <div class="relative border rounded-md overflow-hidden bg-gray-100 aspect-video max-h-96 flex items-center justify-center">
            <img id="previewImage" alt="Preview" class="max-h-96 object-contain" />
          </div>
          <div class="flex gap-2 flex-wrap">
            <button type="button" id="editBtn" class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-medium text-gray-800">Edit / Crop</button>
            <button type="button" id="resetCropBtn" class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-medium text-gray-800 hidden">Reset Crop</button>
          </div>
        </div>

        <button type="submit" class="inline-flex items-center px-4 py-2 rounded-md bg-indigo-600 text-white font-medium hover:bg-indigo-500 disabled:opacity-50" id="submitBtn">Extract Text</button>
      </form>

      <!-- Cropping Modal (Cropper.js) -->
      <div id="cropModal" class="hidden fixed inset-0 bg-black/60 z-40 items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-lg w-full max-w-4xl flex flex-col max-h-[95vh]">
          <div class="flex items-center justify-between px-4 py-2 border-b">
            <h3 class="font-semibold">Crop Image</h3>
            <button id="closeCropModal" class="text-gray-500 hover:text-gray-700">✕</button>
          </div>
          <div class="p-4 flex flex-col gap-4 overflow-auto">
            <div class="relative w-full flex justify-center">
              <img id="cropperImage" alt="To crop" class="max-h-[65vh] select-none" />
            </div>
            <div class="flex flex-wrap items-center gap-2 text-xs">
              <span class="font-medium mr-1">Aspect:</span>
              <button type="button" class="ar-btn px-2 py-1 rounded bg-gray-200 hover:bg-gray-300" data-ar="free">Free</button>
              <button type="button" class="ar-btn px-2 py-1 rounded bg-gray-200 hover:bg-gray-300" data-ar="1">1:1</button>
              <button type="button" class="ar-btn px-2 py-1 rounded bg-gray-200 hover:bg-gray-300" data-ar="1.7777777778">16:9</button>
              <button type="button" class="ar-btn px-2 py-1 rounded bg-gray-200 hover:bg-gray-300" data-ar="0.75">3:4</button>
              <div class="h-6 w-px bg-gray-300 mx-1"></div>
              <label class="flex items-center gap-1">Zoom
                <input id="zoomSlider" type="range" min="0.1" max="3" step="0.01" value="1" class="w-40">
              </label>
              <div class="h-6 w-px bg-gray-300 mx-1"></div>
              <button id="rotateLeft" type="button" class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300">⟲</button>
              <button id="rotateRight" type="button" class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300">⟳</button>
              <button id="resetCropper" type="button" class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300">Reset</button>
            </div>
            <p class="text-xs text-gray-500">Pinch (on touch) or use slider / mousewheel to zoom. Drag to move. Adjust aspect ratio as needed.</p>
          </div>
          <div class="flex gap-3 justify-end px-4 py-3 border-t bg-gray-50">
            <button id="cancelCrop" class="px-4 py-2 text-sm rounded bg-gray-200 hover:bg-gray-300">Cancel</button>
            <button id="applyCrop" class="px-4 py-2 text-sm rounded bg-indigo-600 text-white hover:bg-indigo-500">Apply Crop</button>
          </div>
        </div>
      </div>

      <div id="progress" class="hidden mt-4 text-sm text-indigo-600">Processing... Please wait.</div>
      <div id="error" class="hidden mt-4 text-sm text-red-600"></div>

      <div id="resultWrapper" class="hidden mt-8">
        <h2 class="text-xl font-semibold mb-2">Extracted Text</h2>
        <pre id="resultText" class="whitespace-pre-wrap p-4 bg-gray-900 text-gray-100 rounded-md text-sm overflow-x-auto"></pre>
        <h3 class="text-md font-semibold mt-6 mb-2">Metadata</h3>
        <div id="meta" class="text-sm text-gray-700"></div>
      </div>
    </div>

  <p class="mt-10 text-center text-xs text-gray-500">Backend auto-detected (local vs production). Override with <code>?api=&lt;URL&gt;</code>.</p>
  </div>

  <script src="https://unpkg.com/cropperjs@1.6.2/dist/cropper.min.js"></script>
  <script>
    // OCR text formatting utility with strict & enhanced modes.
    // Spellcheck setup (lazy-load dictionary once). Uses nspell + US English dict.
    const SPELL_CONFIG = {
      aff: 'https://unpkg.com/dictionary-en-us/en_US.aff',
      dic: 'https://unpkg.com/dictionary-en-us/en_US.dic'
    };
    let spellInstance = null;
    let spellLoading = false;
    async function ensureSpellLoaded() {
      if (spellInstance || spellLoading) return spellInstance;
      spellLoading = true;
      try {
        const [affRes, dicRes] = await Promise.all([
          fetch(SPELL_CONFIG.aff),
          fetch(SPELL_CONFIG.dic)
        ]);
        const [affText, dicText] = await Promise.all([affRes.text(), dicRes.text()]);
        if (window.nspell) {
          spellInstance = window.nspell(affText, dicText);
        }
      } catch (e) {
        console.warn('Spell dictionary load failed:', e);
      } finally {
        spellLoading = false;
      }
      return spellInstance;
    }

    // Lightweight Levenshtein distance for confidence heuristic
    function lev(a,b){
      if (a===b) return 0; if (!a) return b.length; if (!b) return a.length;
      const dp = Array(b.length+1).fill(0).map((_,i)=>i); let prevRow;
      for (let i=1;i<=a.length;i++){ prevRow = dp.slice(); dp[0]=i; for (let j=1;j<=b.length;j++){ const cost=a[i-1]===b[j-1]?0:1; dp[j]=Math.min(prevRow[j]+1, dp[j-1]+1, prevRow[j-1]+cost); } }
      return dp[b.length];
    }

    // Core cleanup formatter with optional spell correction.
    // NOTE: Returns string or (if spellcheck enabled and dictionary not yet ready) a Promise resolving to string.
    function formatOcrText(raw, { mode = 'strict', enableDictionary = false, enableSpellCheck = false } = {}) {
      if (!raw || typeof raw !== 'string') return raw || '';
      let text = raw;

      // Normalize line endings first
      text = text.replace(/\r\n?/g, '\n');

      // Collapse multiple spaces (but keep newlines for now)
      text = text.replace(/[ \t]{2,}/g, ' ');

      // Ensure one space after punctuation (comma, period, colon, semicolon, question, exclamation) if followed by a word or quote
      text = text.replace(/([,.;:!?])(?!\s|$)/g, '$1 ');
      text = text.replace(/([,.;:!?])\s{2,}/g, '$1 ');

      // Sentence segmentation (safe): split on punctuation + space(s) when next char looks like start of new sentence
      const sentenceSplit = text
        .split(/(?<=[.!?])\s+(?=[A-Z0-9"'([{])/)
        .map(s => s.trim())
        .filter(Boolean);
      text = sentenceSplit.join('\n\n'); // extra blank line for paragraph-style separation

      const proceedEnhanced = () => {
        if (mode === 'strict') {
          return text; // Do not alter words further
        }

        // Enhanced mode heuristics
        // 1. Apostrophe artifacts (Teacher'_ => Teacher's)
        text = text.replace(/([A-Za-z])['_’]([A-Za-z])/g, "$1'$2");

        // 2. Hyphen/dash normalization for aside (word - word) => spaced en dash
        text = text.replace(/\s-\s/g, ' – ');
        text = text.replace(/([A-Za-z])-(\s)/g, '$1 –$2');

        // 3. Lowercase accidental capital after comma if mixed case afterwards
        text = text.replace(/,\s+([A-Z])(\p{Ll}+)/gu, (m, first, rest) => ', ' + first.toLowerCase() + rest);

        // 4. Ellipsis normalization ('. . .' or spaced) => '...'
        text = text.replace(/(\.)\s+(\.)\s+(\.)/g, '...');

        if (enableDictionary) {
          // Very conservative dictionary corrections at sentence start
          text = text.replace(/(^|\n\n)Thad\b/g, '$1I had');
        }

        // Lowercase stray ' For' -> ' for' when inside sentence (heuristic)
        text = text.replace(/(?<=\b[a-z]) For\b/g, ' for');

        // Trim trailing spaces per line
        text = text.split(/\n/).map(l => l.trimEnd()).join('\n');
        return text;
      };

      text = proceedEnhanced();

      if (!enableSpellCheck) return text;

      // Spellcheck correction (synchronous if dict loaded, otherwise async deferred)
      const techWhitelist = new Set(['Node.js','NestJS','RoR','React','Vue','Angular','Django','Flask','FastAPI','Next.js','Nuxt','Svelte','TypeScript','JavaScript','AWS','Azure','GCP','PostgreSQL','MySQL','MongoDB','Redis','Kafka','Kubernetes','Docker','CI/CD','HTML','CSS']);
      const emailRegex = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/;
      const urlRegex = /^https?:\/\//i;
      const acronymRegex = /^[A-Z]{2,}$/;
      const tokenRegex = /[A-Za-z][A-Za-z'’.-]*/g;

      function preserveCase(original, suggestion){
        if (original === original.toUpperCase()) return suggestion.toUpperCase();
        if (original[0] === original[0].toUpperCase() && original.slice(1) === original.slice(1).toLowerCase()) {
          return suggestion[0].toUpperCase() + suggestion.slice(1).toLowerCase();
        }
        return suggestion; // mixed case keep suggestion as is
      }

      function applySpell(str) {
        if (!spellInstance) return str; // dictionary not ready
        return str.replace(tokenRegex, (tok) => {
          const base = tok.replace(/^[^A-Za-z]+|[^A-Za-z]+$/g,'');
          if (!base) return tok;
          if (emailRegex.test(base) || urlRegex.test(base)) return tok;
          if (techWhitelist.has(base) || techWhitelist.has(base.replace(/\.$/, ''))) return tok;
          if (acronymRegex.test(base) && base.length <= 5) return tok; // treat short acronyms as fixed
          if (/\d/.test(base)) return tok;
          if (base.length <= 2) return tok; // ignore tiny words
          if (spellInstance.correct(base)) return tok;
          const suggestions = spellInstance.suggest(base);
            if (!suggestions || !suggestions.length) return tok;
          const candidate = suggestions[0];
          const distance = lev(base.toLowerCase(), candidate.toLowerCase());
          // Confidence heuristic: allow distance 1 always; distance 2 only if word length > 5; reject others.
          if (distance === 1 || (distance === 2 && base.length > 5)) {
            return preserveCase(tok, candidate);
          }
          return tok;
        });
      }

      if (spellInstance) {
        return applySpell(text);
      }
      // Return a Promise that resolves once dictionary is loaded & applied
      return ensureSpellLoaded().then(() => applySpell(text)).catch(()=>text);
    }
    const form = document.getElementById('ocrForm');
    const progress = document.getElementById('progress');
    const errorEl = document.getElementById('error');
    const resultWrapper = document.getElementById('resultWrapper');
    const resultText = document.getElementById('resultText');
    const metaEl = document.getElementById('meta');
    const submitBtn = document.getElementById('submitBtn');

    function getApiBase() {
      const params = new URLSearchParams(window.location.search);
      const override = params.get('api');
      if (override) return override.replace(/\/$/, '');
      // Prefer injected BACKEND_URL if present (from config.js produced at deploy time)
      if (window.BACKEND_URL) return String(window.BACKEND_URL).replace(/\/$/, '');
      const isLocal = ['localhost','127.0.0.1'].includes(location.hostname);
      return isLocal ? 'http://localhost:8001' : 'https://textify-b0iv.onrender.com';
    }

    // --- Image Preview & Cropping Logic ---
    const imageInput = document.getElementById('imageInput');
    const previewWrapper = document.getElementById('previewWrapper');
    const previewImage = document.getElementById('previewImage');
    const editBtn = document.getElementById('editBtn');
    const resetCropBtn = document.getElementById('resetCropBtn');
    const cropModal = document.getElementById('cropModal');
    const closeCropModal = document.getElementById('closeCropModal');
    const cancelCrop = document.getElementById('cancelCrop');
    const applyCrop = document.getElementById('applyCrop');
    const cropperImage = document.getElementById('cropperImage');
    const aspectButtons = () => Array.from(document.querySelectorAll('.ar-btn'));
    const zoomSlider = document.getElementById('zoomSlider');
    const rotateLeft = document.getElementById('rotateLeft');
    const rotateRight = document.getElementById('rotateRight');
    const resetCropperBtn = document.getElementById('resetCropper');

    let cropper = null;
    let currentImageFile = null; // original file
    let croppedBlob = null;      // cropped output

    imageInput.addEventListener('change', async () => {
      const file = imageInput.files?.[0];
      if (!file) {
        previewWrapper.classList.add('hidden');
        previewImage.src = '';
        currentImageFile = null;
        croppedBlob = null;
        return;
      }
      currentImageFile = file;
      croppedBlob = null;
      resetCropBtn.classList.add('hidden');
      const url = URL.createObjectURL(file);
      previewImage.src = url;
      previewWrapper.classList.remove('hidden');
    });

    editBtn.addEventListener('click', async () => {
      if (!currentImageFile) return;
      cropModal.classList.remove('hidden');
      cropModal.classList.add('flex');
      croppedBlob = null; // reset
      const url = URL.createObjectURL(currentImageFile);
      cropperImage.src = url;
      // Delay instantiation until image loads
      cropperImage.onload = () => {
        if (cropper) { cropper.destroy(); }
        cropper = new Cropper(cropperImage, {
          viewMode: 1,
          dragMode: 'move',
          autoCropArea: 0.9,
          responsive: true,
          background: false,
          modal: true,
          movable: true,
          zoomable: true,
          rotatable: true,
          scalable: false,
          checkOrientation: true,
          wheelZoomRatio: 0.1,
          ready() {
            zoomSlider.value = '1';
            highlightAspect('free');
          },
          zoom(e) {
            // Sync slider
            const imgData = cropper.getImageData();
            const ratio = imgData.scaleX; // approximate
            zoomSlider.value = Math.min(3, Math.max(0.1, ratio)).toString();
          }
        });
      };
    });

    closeCropModal.addEventListener('click', closeModal);
    cancelCrop.addEventListener('click', closeModal);
    function closeModal(){
      cropModal.classList.add('hidden');
      cropModal.classList.remove('flex');
      if (cropper) { cropper.destroy(); cropper = null; }
    }
    function highlightAspect(val) {
      aspectButtons().forEach(btn => {
        if (btn.dataset.ar === val) {
          btn.classList.add('bg-indigo-600','text-white');
          btn.classList.remove('bg-gray-200','text-gray-800');
        } else {
          btn.classList.remove('bg-indigo-600','text-white');
          btn.classList.add('bg-gray-200','text-gray-800');
        }
      });
    }

    aspectButtons().forEach(btn => {
      btn.addEventListener('click', () => {
        const val = btn.dataset.ar;
        highlightAspect(val);
        if (!cropper) return;
        if (val === 'free') {
          cropper.setAspectRatio(NaN);
        } else {
          cropper.setAspectRatio(parseFloat(val));
        }
      });
    });

    zoomSlider.addEventListener('input', () => {
      if (!cropper) return;
      const targetZoom = parseFloat(zoomSlider.value);
      // Compute current ratio vs target, use zoomTo
      cropper.zoomTo(targetZoom);
    });

    rotateLeft.addEventListener('click', () => { if (cropper) cropper.rotate(-90); });
    rotateRight.addEventListener('click', () => { if (cropper) cropper.rotate(90); });
    resetCropperBtn.addEventListener('click', () => { if (cropper) { cropper.reset(); zoomSlider.value = '1'; } });

    applyCrop.addEventListener('click', () => {
      if (!cropper) { closeModal(); return; }
      const canvas = cropper.getCroppedCanvas({
        imageSmoothingQuality: 'high'
      });
      canvas.toBlob(b => {
        if (b) {
          croppedBlob = b;
          previewImage.src = URL.createObjectURL(b);
          resetCropBtn.classList.remove('hidden');
        }
        closeModal();
      }, currentImageFile.type || 'image/png');
    });

    resetCropBtn.addEventListener('click', () => {
      if (currentImageFile) {
        croppedBlob = null;
        previewImage.src = URL.createObjectURL(currentImageFile);
        resetCropBtn.classList.add('hidden');
      }
    });

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      errorEl.classList.add('hidden');
      resultWrapper.classList.add('hidden');
      progress.classList.remove('hidden');
      submitBtn.disabled = true;

      const apiBase = getApiBase();
      const fileInput = document.getElementById('imageInput');
      if (!fileInput.files.length) {
        errorEl.textContent = 'Please choose a file first';
        errorEl.classList.remove('hidden');
        progress.classList.add('hidden');
        submitBtn.disabled = false;
        return;
      }

      const formData = new FormData();
      if (croppedBlob) {
        formData.append('image', new File([croppedBlob], currentImageFile?.name || 'cropped.png', {type: currentImageFile?.type || 'image/png'}));
      } else {
        formData.append('image', fileInput.files[0]);
      }

      try {
        const resp = await fetch(apiBase + '/ocr', {
          method: 'POST',
          body: formData
        });
        if (!resp.ok) {
          const data = await resp.json().catch(() => ({}));
            throw new Error(data.error || 'Request failed');
        }
        const data = await resp.json();
        // Format sentences: split on period followed by space or end, keep punctuation
        const rawText = data.text || '';
        // Choose mode: default strict; can switch to 'enhanced'
        const maybePromise = formatOcrText(rawText, { mode: 'enhanced', enableDictionary: false, enableSpellCheck: true });
        if (maybePromise && typeof maybePromise.then === 'function') {
          const interim = '(Loading dictionary & cleaning...)\n' + (rawText.slice(0,400) || '');
          resultText.textContent = interim;
          maybePromise.then(finalText => {
            resultText.textContent = finalText || '(No text detected)';
          });
        } else {
          resultText.textContent = maybePromise || '(No text detected)';
        }
        metaEl.innerHTML = `Word count: ${data.meta?.word_count ?? '-'}<br/>Average confidence: ${data.meta?.average_confidence ?? '-'}<br/>Tesseract: ${data.meta?.tesseract_version ?? '-'}`;
        resultWrapper.classList.remove('hidden');
      } catch (err) {
        errorEl.textContent = err.message;
        errorEl.classList.remove('hidden');
      } finally {
        progress.classList.add('hidden');
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
